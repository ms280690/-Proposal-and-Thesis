Prog "Dequeue" ["Prelude"] [Type ("Dequeue","Queue") Public [0] [Cons ("Dequeue","S") 4 Private [TCons ("Prelude","Int") [],TCons ("Prelude","[]") [TVar 0],TCons ("Prelude","Int") [],TCons ("Prelude","[]") [TVar 0]]]] [Func ("Dequeue","empty") 0 Public (TCons ("Dequeue","Queue") [TVar 0]) (Rule [] (Comb ConsCall ("Dequeue","S") [Lit (Intc  0),Comb ConsCall ("Prelude","[]") [],Lit (Intc  0),Comb ConsCall ("Prelude","[]") []])),Func ("Dequeue","isEmpty") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Prelude","Bool") [])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Comb FuncCall ("Prelude","==") [Comb FuncCall ("Prelude","+") [Var 2,Var 4],Lit (Intc  0)])])),Func ("Dequeue","deqHead") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TVar 0)) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Comb FuncCall ("Prelude","head") [Case  Rigid (Comb FuncCall ("Prelude","==") [Var 2,Lit (Intc  0)]) [Branch (Pattern ("Prelude","True") []) (Var 5),Branch (Pattern ("Prelude","False") []) (Var 3)]])])),Func ("Dequeue","deqLast") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TVar 0)) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Comb FuncCall ("Prelude","head") [Case  Rigid (Comb FuncCall ("Prelude","==") [Var 4,Lit (Intc  0)]) [Branch (Pattern ("Prelude","True") []) (Var 3),Branch (Pattern ("Prelude","False") []) (Var 5)]])])),Func ("Dequeue","cons") 2 Public (FuncType (TVar 0) (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0]))) (Rule [1,2] (Case  Flex (Var 2) [Branch (Pattern ("Dequeue","S") [3,4,5,6]) (Comb FuncCall ("Dequeue","check") [Comb FuncCall ("Prelude","+") [Var 3,Lit (Intc  1)],Comb ConsCall ("Prelude",":") [Var 1,Var 4],Var 5,Var 6])])),Func ("Dequeue","deqTail") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Case  Flex (Var 3) [Branch (Pattern ("Prelude","[]") []) (Comb FuncCall ("Dequeue","empty") []),Branch (Pattern ("Prelude",":") [6,7]) (Comb FuncCall ("Dequeue","deqReverse") [Comb FuncCall ("Dequeue","check") [Var 4,Var 5,Comb FuncCall ("Prelude","-") [Var 2,Lit (Intc  1)],Var 7]])])])),Func ("Dequeue","snoc") 2 Public (FuncType (TVar 0) (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0]))) (Rule [1,2] (Case  Flex (Var 2) [Branch (Pattern ("Dequeue","S") [3,4,5,6]) (Comb FuncCall ("Dequeue","deqReverse") [Comb FuncCall ("Dequeue","check") [Comb FuncCall ("Prelude","+") [Var 5,Lit (Intc  1)],Comb ConsCall ("Prelude",":") [Var 1,Var 6],Var 3,Var 4]])])),Func ("Dequeue","deqInit") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Case  Flex (Var 5) [Branch (Pattern ("Prelude","[]") []) (Comb FuncCall ("Dequeue","empty") []),Branch (Pattern ("Prelude",":") [6,7]) (Comb FuncCall ("Dequeue","check") [Var 2,Var 3,Comb FuncCall ("Prelude","-") [Var 4,Lit (Intc  1)],Var 7])])])),Func ("Dequeue","deqReverse") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Comb ConsCall ("Dequeue","S") [Var 4,Var 5,Var 2,Var 3])])),Func ("Dequeue","check") 4 Private (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","[]") [TVar 0]) (FuncType (TCons ("Prelude","Int") []) (FuncType (TCons ("Prelude","[]") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0]))))) (Rule [1,2,3,4] (Let [(5,Comb FuncCall ("Prelude","+") [Var 1,Var 3])] (Let [(6,Comb FuncCall ("Prelude","div") [Var 5,Lit (Intc  2)])] (Let [(7,Comb FuncCall ("Prelude","-") [Var 5,Var 6])] (Let [(8,Comb FuncCall ("Prelude","splitAt") [Var 6,Var 2])] (Let [(9,Comb FuncCall ("Dequeue","check._#selFP3#f'") [Var 8])] (Let [(10,Comb FuncCall ("Dequeue","check._#selFP4#rf'") [Var 8])] (Let [(11,Comb FuncCall ("Prelude","++") [Var 4,Comb FuncCall ("Prelude","apply") [Comb FuncCall ("Prelude","reverse") [],Var 10]])] (Case  Rigid (Comb FuncCall ("Prelude","<=") [Var 1,Comb FuncCall ("Prelude","+") [Comb FuncCall ("Prelude","*") [Lit (Intc  3),Var 3],Lit (Intc  1)]]) [Branch (Pattern ("Prelude","True") []) (Comb ConsCall ("Dequeue","S") [Var 1,Var 2,Var 3,Var 4]),Branch (Pattern ("Prelude","False") []) (Case  Rigid (Comb FuncCall ("Prelude","otherwise") []) [Branch (Pattern ("Prelude","True") []) (Comb ConsCall ("Dequeue","S") [Var 6,Var 9,Var 7,Var 11]),Branch (Pattern ("Prelude","False") []) (Comb FuncCall ("Prelude","failed") [])])]))))))))),Func ("Dequeue","check._#selFP3#f'") 1 Private (FuncType (TCons ("Prelude","(,)") [TCons ("Prelude","[]") [TVar 45],TCons ("Prelude","[]") [TVar 45]]) (TCons ("Prelude","[]") [TVar 45])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Prelude","(,)") [2,3]) (Var 2)])),Func ("Dequeue","check._#selFP4#rf'") 1 Private (FuncType (TCons ("Prelude","(,)") [TCons ("Prelude","[]") [TVar 45],TCons ("Prelude","[]") [TVar 45]]) (TCons ("Prelude","[]") [TVar 45])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Prelude","(,)") [2,3]) (Var 3)])),Func ("Dequeue","listToDeq") 1 Public (FuncType (TCons ("Prelude","[]") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0])) (Rule [1] (Comb FuncCall ("Dequeue","check") [Comb FuncCall ("Prelude","length") [Var 1],Var 1,Lit (Intc  0),Comb ConsCall ("Prelude","[]") []])),Func ("Dequeue","deqToList") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Prelude","[]") [TVar 0])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Comb FuncCall ("Prelude","++") [Var 3,Comb FuncCall ("Prelude","apply") [Comb FuncCall ("Prelude","reverse") [],Var 5]])])),Func ("Dequeue","deqLength") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Prelude","Int") [])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Comb FuncCall ("Prelude","+") [Var 2,Var 4])])),Func ("Dequeue","rotate") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Dequeue","Queue") [TVar 0])) (Rule [1] (Comb FuncCall ("Dequeue","snoc") [Comb FuncCall ("Dequeue","deqHead") [Var 1],Comb FuncCall ("Dequeue","deqTail") [Var 1]])),Func ("Dequeue","matchHead") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Prelude","Maybe") [TCons ("Prelude","(,)") [TVar 0,TCons ("Dequeue","Queue") [TVar 0]]])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Case  Flex (Var 3) [Branch (Pattern ("Prelude","[]") []) (Case  Flex (Var 5) [Branch (Pattern ("Prelude","[]") []) (Comb ConsCall ("Prelude","Nothing") []),Branch (Pattern ("Prelude",":") [6,7]) (Case  Flex (Var 7) [Branch (Pattern ("Prelude","[]") []) (Comb ConsCall ("Prelude","Just") [Comb ConsCall ("Prelude","(,)") [Var 6,Comb FuncCall ("Dequeue","empty") []]])])]),Branch (Pattern ("Prelude",":") [8,9]) (Comb ConsCall ("Prelude","Just") [Comb ConsCall ("Prelude","(,)") [Var 8,Comb FuncCall ("Dequeue","deqReverse") [Comb FuncCall ("Dequeue","check") [Var 4,Var 5,Comb FuncCall ("Prelude","-") [Var 2,Lit (Intc  1)],Var 9]]]])])])),Func ("Dequeue","matchLast") 1 Public (FuncType (TCons ("Dequeue","Queue") [TVar 0]) (TCons ("Prelude","Maybe") [TCons ("Prelude","(,)") [TVar 0,TCons ("Dequeue","Queue") [TVar 0]]])) (Rule [1] (Case  Flex (Var 1) [Branch (Pattern ("Dequeue","S") [2,3,4,5]) (Case  Flex (Var 5) [Branch (Pattern ("Prelude","[]") []) (Case  Flex (Var 3) [Branch (Pattern ("Prelude","[]") []) (Comb ConsCall ("Prelude","Nothing") []),Branch (Pattern ("Prelude",":") [6,7]) (Case  Flex (Var 7) [Branch (Pattern ("Prelude","[]") []) (Comb ConsCall ("Prelude","Just") [Comb ConsCall ("Prelude","(,)") [Var 6,Comb FuncCall ("Dequeue","empty") []]])])]),Branch (Pattern ("Prelude",":") [8,9]) (Comb ConsCall ("Prelude","Just") [Comb ConsCall ("Prelude","(,)") [Var 8,Comb FuncCall ("Dequeue","check") [Var 2,Var 3,Comb FuncCall ("Prelude","-") [Var 4,Lit (Intc  1)],Var 9]]])])]))] []